//TODO: The class and methods in this file are currently public
// We want to eventually make them internal.
// This is blocked by csbindgen making all methods public.
// See: https://github.com/Cysharp/csbindgen/pull/83
// <auto-generated>
// This code is generated by csbindgen.
// DON'T CHANGE THIS DIRECTLY.
// </auto-generated>
#pragma warning disable CS8500
#pragma warning disable CS8981
using System;
using System.Runtime.InteropServices;


namespace PeerDAS.Native
{
    public static unsafe partial class NativeMethods
    {
        const string __DllName = "c_peerdas_kzg";



        /// <summary>Create a new PeerDASContext and return a pointer to it.  # Memory faults  To avoid memory leaks, one should ensure that the pointer is freed after use by calling `peerdas_context_free`.</summary>
        [DllImport(__DllName, EntryPoint = "peerdas_context_new", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern PeerDASContext* peerdas_context_new();

        /// <summary># Safety  - The caller must ensure that the pointer is valid. If the pointer is null, this method will return early. - The caller should also avoid a double-free by setting the pointer to null after calling this method.  # Memory faults  - If this method is called twice on the same pointer, it will result in a double-free.  # Undefined behavior  - Since the `ctx` is created in Rust, we can only get undefined behavior, if the caller passes in a pointer that was not created by `peerdas_context_new`.</summary>
        [DllImport(__DllName, EntryPoint = "peerdas_context_free", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void peerdas_context_free(PeerDASContext* ctx);

        /// <summary>Free the memory allocated for the error message.  # Safety  - The caller must ensure that the pointer is valid. If the pointer is null, this method will return early. - The caller should also avoid a double-free by setting the pointer to null after calling this method.</summary>
        [DllImport(__DllName, EntryPoint = "free_error_message", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern void free_error_message(byte* c_message);

        /// <summary>Compute a commitment from a Blob  # Safety  - The caller must ensure that the pointers are valid. - The caller must ensure that `blob` points to a region of memory that is at least `BYTES_PER_BLOB` bytes. - The caller must ensure that `out` points to a region of memory that is at least `BYTES_PER_COMMITMENT` bytes.  # Undefined behavior  - This implementation will check if the ctx pointer is null, but it will not check if the other arguments are null. If the other arguments are null, this method will dereference a null pointer and result in undefined behavior.</summary>
        [DllImport(__DllName, EntryPoint = "peerdas_blob_to_kzg_commitment", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CResult peerdas_blob_to_kzg_commitment(PeerDASContext* ctx, byte* blob, byte* @out);

        /// <summary>Computes the cells and KZG proofs for a given blob.  # Safety  - The caller must ensure that the pointers are valid. If pointers are null. - The caller must ensure that `blob` points to a region of memory that is at least `BYTES_PER_BLOB` bytes. - The caller must ensure that `out_cells` points to a region of memory that is at least `CELLS_PER_EXT_BLOB` elements and that each element is at least `BYTES_PER_CELL` bytes. - The caller must ensure that `out_proofs` points to a region of memory that is at least `CELLS_PER_EXT_BLOB` elements and that each element is at least `BYTES_PER_COMMITMENT` bytes.  # Undefined behavior  - This implementation will check if the ctx pointer is null, but it will not check if the other arguments are null. If the other arguments are null, this method will dereference a null pointer and result in undefined behavior.</summary>
        [DllImport(__DllName, EntryPoint = "peerdas_compute_cells_and_kzg_proofs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CResult peerdas_compute_cells_and_kzg_proofs(PeerDASContext* ctx, byte* blob, byte** out_cells, byte** out_proofs);

        /// <summary>Verifies a cell corresponds to a particular commitment.  # Safety  - The caller must ensure that the pointers are valid. - The caller must ensure that `cell` points to a region of memory that is at least `BYTES_PER_CELLS` bytes. - The caller must ensure that `commitment` points to a region of memory that is at least `BYTES_PER_COMMITMENT` bytes. - The caller must ensure that `proof` points to a region of memory that is at least `BYTES_PER_COMMITMENT` bytes. - The caller must ensure that `verified` points to a region of memory that is at least 1 byte. # Undefined behavior - This implementation will check if the ctx pointer is null, but it will not check if the other arguments are null. If the other arguments are null, this method will dereference a null pointer and result in undefined behavior. </summary>
        [DllImport(__DllName, EntryPoint = "peerdas_verify_cell_kzg_proof", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CResult peerdas_verify_cell_kzg_proof(PeerDASContext* ctx, byte* cell, byte* commitment, ulong cell_id, byte* proof, bool* verified);

        /// <summary>Verifies a batch of cells and their KZG proofs.  # Safety  - If the length parameter for a pointer is set to zero, then this implementation will not check if its pointer is null. This is because the caller might have passed in a null pointer, if the length is zero. Instead an empty slice will be created.  - The caller must ensure that the pointers are valid. - The caller must ensure that `row_commitments` points to a region of memory that is at least `row_commitments_length` commitments and that each commitment is at least `BYTES_PER_COMMITMENT` bytes. - The caller must ensure that `row_indices` points to a region of memory that is at least `num_cells` elements and that each element is 8 bytes. - The caller must ensure that `column_indices` points to a region of memory that is at least `num_cells` elements and that each element is 8 bytes. - The caller must ensure that `cells` points to a region of memory that is at least `cells_length` proof and that each cell is at least `BYTES_PER_CELL` bytes - The caller must ensure that `proofs` points to a region of memory that is at least `proofs_length` proofs and that each proof is at least `BYTES_PER_COMMITMENT` bytes. - The caller must ensure that `verified` points to a region of memory that is at least 1 byte.  # Undefined behavior  - This implementation will check if the ctx pointer is null, but it will not check if the other arguments are null. If the other arguments are null, this method will dereference a null pointer and result in undefined behavior.</summary>
        [DllImport(__DllName, EntryPoint = "peerdas_verify_cell_kzg_proof_batch", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CResult peerdas_verify_cell_kzg_proof_batch(PeerDASContext* ctx, ulong row_commitments_length, byte** row_commitments, ulong row_indices_length, ulong* row_indices, ulong column_indices_length, ulong* column_indices, ulong cells_length, byte** cells, ulong proofs_length, byte** proofs, bool* verified);

        /// <summary>Recovers all cells and their KZG proofs from the given cell ids and cells  # Safety  - If the length parameter for a pointer is set to zero, then this implementation will not check if its pointer is null. This is because the caller might have passed in a null pointer, if the length is zero. Instead an empty slice will be created.  - The caller must ensure that the pointers are valid. - The caller must ensure that `cells` points to a region of memory that is at least `cells_length` cells and that each cell is at least `BYTES_PER_CELL` bytes. - The caller must ensure that `cell_ids` points to a region of memory that is at least `cell_ids_length` cell ids and that each cell id is 8 bytes. - The caller must ensure that `out_cells` points to a region of memory that is at least `CELLS_PER_EXT_BLOB` cells and that each cell is at least `BYTES_PER_CELL` bytes. - The caller must ensure that `out_proofs` points to a region of memory that is at least `CELLS_PER_EXT_BLOB` proofs and that each proof is at least `BYTES_PER_COMMITMENT` bytes.  # Undefined behavior  - This implementation will check if the ctx pointer is null, but it will not check if the other arguments are null. If the other arguments are null, this method will dereference a null pointer and result in undefined behavior.</summary>
        [DllImport(__DllName, EntryPoint = "peerdas_recover_cells_and_proofs", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern CResult peerdas_recover_cells_and_proofs(PeerDASContext* ctx, ulong cells_length, byte** cells, ulong cell_ids_length, ulong* cell_ids, byte** out_cells, byte** out_proofs);

        [DllImport(__DllName, EntryPoint = "constant_bytes_per_cell", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ulong constant_bytes_per_cell();

        [DllImport(__DllName, EntryPoint = "constant_bytes_per_proof", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ulong constant_bytes_per_proof();

        [DllImport(__DllName, EntryPoint = "constant_cells_per_ext_blob", CallingConvention = CallingConvention.Cdecl, ExactSpelling = true)]
        public static extern ulong constant_cells_per_ext_blob();


    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct PeerDASContext
    {
    }

    [StructLayout(LayoutKind.Sequential)]
    public unsafe partial struct CResult
    {
        public CResultStatus status;
        public byte* error_msg;
    }


    public enum CResultStatus : uint
    {
        Ok,
        Err,
    }


}
